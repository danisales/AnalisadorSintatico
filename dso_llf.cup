package cup;

import java_cup.runtime.*;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;
import Lexer;
import ast.*;
import visitor.*;

parser code {:
  protected Lexer lexer;
:}

init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

terminal AND, LESST, EQUALOP, NOTEQUAL, PLUS, MINUS, TIMES, NOT, SEMI,
         DOT, COMMA, EQUAL, LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET,
         BOOL, CLASS, PUBLIC, EXTENDS, STATIC, VOID, MAIN, STRING, INT, WHILE, IF,
         ELSE, RETURN, LENGTH, THIS, NEW, SYSO;
terminal Boolean TRUE, FALSE;
terminal Integer INTEGER;
terminal String ID;

non terminal Program goal;

non terminal MainClass mainClass;

non terminal ClassDecl classDecl;
non terminal ClassDeclList classList;

non terminal Identifier ident;

non terminal Statement stmt;
non terminal StatementList stmtList;

non terminal VarDecl varDecl;
non terminal VarDeclList varList;

non terminal MethodDecl methodDecl;
non terminal MethodDeclList methodList;

non terminal Formal formal;
non terminal FormalList formalList;

non terminal Exp expr;
non terminal ExpList exprList;

non terminal Type type;

//Precedências
//http://cseweb.ucsd.edu/~ricko/CSE11/Java_Operator_Precedence_Table.pdf

precedence right EQUAL;
precedence left AND;
precedence left EQUALOP, NOTEQUAL;
precedence left LESST;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence right NOT, NEW;
precedence left DOT;

/* Gramática usada
Goal ::= MainClass ( ClassDeclaration )* <EOF>

MainClass ::= "class" Identifier "{" "public" "static" "void" "main" "(" "String" "[" "]" Identifier ")"
"{" Statement "}" "}"

ClassDeclaration ::= "class" Identifier ( "extends" Identifier )? "{" ( VarDeclaration )* (
MethodDeclaration )* "}"

VarDeclaration ::= Type Identifier ";"

MethodDeclaration ::= "public" Type Identifier "(" ( Type Identifier ( "," Type Identifier )* )? ")" "{" (
VarDeclaration )* ( Statement )* "return" Expression ";" "}"

Type ::= "int" "[" "]"
| "boolean"
| "int"
| Identifier

Statement ::= "{" ( Statement )* "}"
| "if" "(" Expression ")" Statement "else" Statement
| "while" "(" Expression ")" Statement
| "System.out.println" "(" Expression ")" ";"
| Identifier "=" Expression ";"
| Identifier "[" Expression "]" "=" Expression ";"

Expression ::= Expression ( "&&" | "<" | "+" | "­" | "*" ) Expression
| Expression "[" Expression "]"
| Expression "." "length"
| Expression "." Identifier "(" ( Expression ( "," Expression )* )? ")"
| <INTEGER_LITERAL>
| "true"
| "false"
| Identifier
| "this"
| "new" "int" "[" Expression "]"
| "new" Identifier "(" ")"
| "!" Expression
| "(" Expression ")"

Identifier ::= <IDENTIFIER> */

start with goal;

goal ::= mainClass:main classList:classes {: RESULT = new Program (main, classes); :};

mainClass ::= CLASS ident:name LBRACKET PUBLIC STATIC VOID MAIN LPAREN STRING LBRACE RBRACE ident:args RPAREN
              LBRACKET stmt:stmt RBRACKET RBRACKET {: RESULT = new MainClass(name, args, stmt); :};

classList ::= classList:classes classDecl:cls {: classes.addElement(cls);
                                                  RESULT = classes; :}
                                              | {: RESULT = new ClassDeclList(); :};

classDecl ::= CLASS ident:name LBRACKET varList:varLs methodList:mtdLs RBRACKET
              {: RESULT = new ClassDeclSimple(name, varLs, mtdLs); :}
            | CLASS ident:name EXTENDS ident:extClass LBRACKET varList:varLs methodList:mtdLs RBRACKET
            {: RESULT = new ClassDeclExtends(name, extClass, varLs, mtdLs); :};

varList ::= varList:vars varDecl:var {: vars.addElement(vars); RESULT = vars; :}
                                  | {: RESULT = new VarDeclList(); :};

varDecl ::= type:tp ident:id SEMI {: RESULT = new VarDecl(tp, id); :};

methodList ::= methodList:mtds methodDecl:mtd {: mtds.addElement(mtd);
                                                  RESULT = mtds; :}
                                              | {: RESULT = new MethodDeclList(); :};

methodDecl ::= PUBLIC type:tp ident:id LPAREN formalList:formalLs RPAREN LBRACKET varList:vars stmtList:stmtLs
              RETURN expr:expr SEMI RBRACKET {: RESULT = new MethodDecl(tp, id, formalLs, vars, stmtLs,expr); :};
